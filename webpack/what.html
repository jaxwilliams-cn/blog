<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>webpack 是什么？</title>
    <meta name="generator" content="VuePress 1.7.1">
    
    <meta name="description" content="">
    
    <link rel="preload" href="/assets/css/0.styles.775e5fee.css" as="style"><link rel="preload" href="/assets/js/app.79ac543d.js" as="script"><link rel="preload" href="/assets/js/2.10178664.js" as="script"><link rel="preload" href="/assets/js/11.4bc5bc5f.js" as="script"><link rel="prefetch" href="/assets/js/10.748396af.js"><link rel="prefetch" href="/assets/js/3.0d0d0c7c.js"><link rel="prefetch" href="/assets/js/4.6fd1ef01.js"><link rel="prefetch" href="/assets/js/5.15184a61.js"><link rel="prefetch" href="/assets/js/6.ffe6f60a.js"><link rel="prefetch" href="/assets/js/7.dee03a64.js"><link rel="prefetch" href="/assets/js/8.0f807b60.js"><link rel="prefetch" href="/assets/js/9.ce20b86e.js">
    <link rel="stylesheet" href="/assets/css/0.styles.775e5fee.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container no-sidebar"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <!----></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><!---->  <!----> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="webpack-是什么"><a href="#webpack-是什么" class="header-anchor">#</a> webpack 是什么？</h1> <p>需要牢牢记住并强调的一点：webpack 只是一个静态模块打包器（static module bundler）</p> <p>它所承担的核心指责就是生成一张依赖图（dependency graph）并最终合成一个或多个包（bundle）</p> <p><em>这意味着：当你发现你的 eslint 报错时，请查阅 eslint 文档，而不是搜索为什么 webpack 报错</em></p> <h2 id="static-module-bundler"><a href="#static-module-bundler" class="header-anchor">#</a> static module bundler</h2> <p>打包器，顾名思义，将多个文件合成为一个文件。</p> <p>它是根据模块的引用关系来生成依赖图，因此 webpack 最关键的就是如何索引，处理这些模块语法和引用关系。</p> <p>webpack 只能处理静态资源(static assets)</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">const</span> staticImage <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'static/xxx.png'</span><span class="token punctuation">)</span> <span class="token comment">// 静态资源</span>
<span class="token keyword">const</span> imageName <span class="token operator">=</span> <span class="token string">'xxx.png'</span>
<span class="token keyword">const</span> dynamicImage <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">static/</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>imageName<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span> <span class="token comment">// 动态资源</span>
</code></pre></div><h2 id="webpack-因何诞生"><a href="#webpack-因何诞生" class="header-anchor">#</a> webpack 因何诞生</h2> <p>要回答 why webpack, 实际上就是要回答 why static module bundler。</p> <p>没有 webpack 时我们遇到了什么问题</p> <ol><li>代码太多了（工程规模大）
JS 早期的设计只是为了能在页面里实现一些简单的交互，随着网速的提升，Ajax 的出现和浏览器的升级，越来越多的功能从服务端转移到前端，且交互越来越复杂，UI 对动效等的要求也在提升，需要实现的功能多了，工程规模自然庞大了，对于模块化的需求也应运而生，而 JS 早期的设计中并没有考虑到模块化的问题（不同域的脚本甚至共享一个命名空间）。
因此当时出现了 CMD（Commonjs，同步，服务于 nodejs 服务端），AMD（Requirejs，异步，服务于浏览器端），后来制定了标准 ES Modules。
很可惜，早期由于标准不统一，浏览器没有实现，即使现代浏览器普遍支持 ES Modules（支持到的 stage 各有不同），但是用户浏览器（IE8,11）更新换代需要时间，因此至今仍然无法直接在生产环境中直接使用模块化语法。</li> <li>HTTP1.1（并行限制和包头浪费）
在 chrome 中，HTTP1.1 的同域名并行请求限制为 6 个，即如果同时有 10 个 HTTP1.1 的请求，那么只能同时请求 6 个，剩余 4 个得排队等待前面的请求完成。
这意味着即使客户的浏览器支持模块化语法，但是因为同域名的并行限制，也会极大程度上影响用户网页的加载速度。
是不是浏览器放开限制，就不存在这个问题呢？很不幸，不是，每一次 HTTP 传输都需要附带 HTTP 包头，包头中的绝大多数字段都是重复的，对业务无意义的，因此这一部分的网络传输时间实质上也是算到了用户头上，影响了网页的加载速度。</li></ol> <p><em>说明：通常 webpack 用于打包面向服务器的代码，因为 nodejs 自身支持 CJS 规范，且 nodejsv13 起支持 ES Modules(mjs)</em></p> <p><em>说明：CJS 是随着 Nodejs 的流行而流行的，因此，CommonJS 的生态的繁荣要远胜于 AMD，尽管当时有一些项目同时支持了两种规范，还有 UMD 的通用包装</em></p> <h3 id="webpack-解决的核心问题"><a href="#webpack-解决的核心问题" class="header-anchor">#</a> webpack 解决的核心问题</h3> <ol><li>将模块化的源文件打包为一个或多个文件</li> <li>支持尽可能多的模块化规范</li></ol> <h3 id="不止于此"><a href="#不止于此" class="header-anchor">#</a> 不止于此</h3> <p>webpack 如果只是止步于模块打包器，那么它也不会像如今一般无处不在。</p> <p>在这之前，还是先看看需要解决的问题</p> <ol><li>ES6
ES6 的标准一经发布就广受欢迎（块级作用域、解构、箭头表达式、类、Promise）实实在在的解决了开发者的痛点，开发者们已经迫不及待要上马 ES6 了。
但是老大难的问题又来了，用户的浏览器的升级换代需要时间，浏览器对最新标准的支持也需要时间。
幸运的是，JS 语言的灵活性使得可以用 ES5 的语法实现浏览器所不支持的 ES6 语法，这被称为 polyfill 和 transform，实现这一特性的是 core-js，集成工具是 babel。</li> <li>其他非 JS 资源的打包问题
有些资源虽然不属于 JS Module 的一部分，但是对于其实也是有对它按模块进行处理的需求的，
例如图片，需要对它做引用路径的转换，小的图片直接转为 base64，
例如 CSS，需要对它做引用路径的转换或嵌入到页面的 style 标签中，甚至更进一步可以做预处理
例如 TS，需要将其转换为 JS</li> <li>开发效率低
随着 JS 工程体量的增大和前置步骤的增多（TS 转 JS，SASS 转 CSS，ejs 转 html，图片压缩等），每一次的修改都需要漫长的重新编译，并刷新页面来重新预览。
因此热更新的需求也是与日俱增。
热更新即 启动服务 -&gt; 客户端监听 websocket -&gt; 开发者修改源文件 -&gt; 目标文件更新 -&gt; websocket 通知客户端 -&gt; 客户端拉取更新 -&gt; 客户端热更新或自动刷新</li></ol> <p><em>以上提到的这些问题如果是直接使用脚手架如 CRA 等，是不了解曾经的开发者们一路走来的幸苦的，在 15 年时，还是 Grunt 和 Gulp 的天下，任务都需要自己配置，需要预先规划代码结构，同时离不开的工具还有 livereload</em></p> <p>webpack 解决了以上问题：</p> <ol><li><strong>Loader</strong>，webpack 将所有引用依赖关系都视为模块，默认可以处理的模块是 JS、JSON、WebAssembly，对于默认不支持的模块类型，webpack 提供了 Loader 来接入，
例如 Babel，Babel 自身提供了命令行和多种集成方式，在 webpack 中，它的集成是通过<code>babel-loader</code>，简单的配置后，所有的 JS 模块在引用前都会被 babel 预处理。
同理的还有各式资源文件，<code>raw-loader</code>,<code>url-loder</code>,<code>file-loader</code>是三种常见的 loader 用于对资源文件进行引用和处理。
在 webpack 的设计里，Loader 可以串联执行，这就留下了很丰富的想象空间，例如 SCSS 文件，可以先使用<code>sass-loader</code>转换为 css，再使用<code>postcss-loader</code>进行<code>autoprefixer</code>,<code>cssnano</code>等操作，最后使用<code>css-loader</code>来正确解析 CSS 模块，最后使用<code>style-loader</code>使得该 CSS 文件在运行时可以作为<code>style</code>标签的内容被插入到页面中。</li> <li><strong>HMR(webpack-dev-server)</strong>，模块热更新，webpack 保存了模块之间的依赖关系，这意味这当我们修改某个文件时，webpack 可以仅替换、添加或删除对应模块，同时 webpack 还做到了保留应用状态，只更新变更内容，非常的强大。
要做到这一点，需要编译器（compiler），模块 Loader 实现 HMR 接口，运行时（runtime）配合运作，webpack 的设计使得这一切有可能发生。</li></ol> <p>webpack 为了拓展自己的能力，还做了一些额外的工作</p> <ol><li><strong>Plugin</strong>，loader 还是有许多能力无法实现，例如需要编译上下文的功能、额外生成文件的功能，这些能力通通交由 Plugin 来实现。
webpack 直接将编译器上下文提供给了插件，并提供了大量非常实用的钩子函数，这意味着插件可以在 webpack 编译的任何环节做自定义的修改，以实现非常强大的功能，
例如 SplitChunksPlugin，提供了对 webpack 输出 bundle 的任意裁剪组合。</li> <li><strong>Tree Shaking</strong>，webpack 不满足于仅仅生成依赖图并按依赖图拼接文件，它深入代码细节，剔除掉没有副作用的没有被引用的模块或文件，这为包大小的优化提供了最大的可能性。</li> <li><strong>Sourcemap</strong>，webpack 输出的通常是经过转换后的代码，Souremap 是调试中避不开的一环，webpack 不仅提供了默认支持模块的 Souremap 支持，也为第三方 Loader 提供了生成 souremap 的接口，只要正确配置，即使你的 CSS 文件经历了 5 道转换流程，最终依然可以通过 Souremap 找回源代码。</li></ol> <p>此外，webpack 为了提升大型项目的性能，采取了很多优化措施。</p> <h2 id="webpack-的局限性"><a href="#webpack-的局限性" class="header-anchor">#</a> webpack 的局限性</h2> <p>webpack 诞生的背景是 JS 生态模块化不规范，浏览器支持不到位的年代，
在如今 2020 年，ES Module 统一标准，旧的浏览器（Android4.4，IE8,11）即将淘汰，HTTP2 的部署环境已然成熟的年代，
我们写的源代码不需要打包也是有可能直接跑在浏览器上的，即 bundless 概念
vite,snowpack 等这些就是基于这样的理念而诞生的。</p></div> <footer class="page-edit"><!----> <!----></footer> <!----> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.79ac543d.js" defer></script><script src="/assets/js/2.10178664.js" defer></script><script src="/assets/js/11.4bc5bc5f.js" defer></script>
  </body>
</html>
